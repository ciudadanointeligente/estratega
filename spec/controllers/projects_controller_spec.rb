require 'rails_helper'

# This spec was generated by rspec-rails when you ran the scaffold generator.
# It demonstrates how one might use RSpec to specify the controller code that
# was generated by Rails when you ran the scaffold generator.
#
# It assumes that the implementation code is generated by the rails scaffold
# generator.  If you are using any extension libraries to generate different
# controller code, this generated spec may or may not pass.
#
# It only uses APIs available in rails and/or rspec-rails.  There are a number
# of tools you can use to make these specs even more expressive, but we're
# sticking to rails and rspec-rails APIs to keep things simple and stable.
#
# Compared to earlier versions of this generator, there is very limited use of
# stubs and message expectations in this spec.  Stubs are only used when there
# is no simpler way to get a handle on the object needed for the example.
# Message expectations are only used when there is no simpler way to specify
# that an instance is receiving a specific message.

RSpec.describe ProjectsController, :type => :controller do

  # This should return the minimal set of attributes required to create a valid
  # Project. As you add validations to Project, be sure to
  # adjust the attributes here as well.
  let(:valid_attributes) {
    {
      title: "a Project",
      description: "a Description",
      public: true,
      focus_area: "Improve maternal health"
    }
  }

  let(:valid_attributes_no_public) {
    {
      title: "a Project",
      description: "a Description",
      public: false,
      focus_area: "Improve maternal health"
    }
  }

  let(:invalid_attributes) {
    {
      title: "",
      description: "a Description",
      focus_area: ""
    }
  }

  before(:each) do
    @project = create(:project)
  end

  # This should return the minimal set of values that should be in the session
  # in order to pass any filters (e.g. authentication) defined in
  # ProjectsController. Be sure to keep this updated too.
  let(:valid_session) {
    {"warden.user.user.key" => session["warden.user.user.key"]}
  }

  login_user

  describe "GET index" do
    it "retrieves all user projects" do
      owner = User.find(valid_session["warden.user.user.key"][0][0])
      project_one = create(:project)
      project_one.users << owner
      project_two = create(:project)
      project_two.users << create(:user)

      get :index, {}, valid_session
      expect(assigns(:projects)).to include(project_one)
      expect(assigns(:projects)).not_to include(project_two)
    end

    it "retrieve all public projects" do
      private_project = create(:project)
      public_project = create(:project)
      public_project.public = true
      public_project.save

      get :index, {public: true}, valid_session
      expect(assigns(:projects)).to include(public_project)
      expect(assigns(:projects)).to_not include(private_project)
    end
  end

  describe "GET show" do
    it "assigns the requested project as @project" do
      project = Project.create! valid_attributes
      get :show, {:id => project.to_param}, valid_session
      expect(assigns(:project)).to eq(project)
    end

    it "showing a project for an authorized user" do
      project = create(:project)
      user_01 = create(:user)
      project.users << user_01
      user_02 = create(:user)

      get :show, {:id => project.to_param}, valid_session

      expect(assigns(:project).users).to_not include(user_02)
      expect(assigns(:project).users).to include(user_01)
    end
  end

  describe "GET overview" do
    it "assigns the requested project as @project" do
      project = Project.create! valid_attributes
      get :overview, {:id => project.to_param}, valid_session
      expect(assigns(:project)).to eq(project)
    end
  end

  describe "GET new" do
    it "assigns a new project as @project" do
      get :new, {}, valid_session
      expect(assigns(:project)).to be_a_new(Project)
    end
  end

  describe "GET edit" do
    it "assigns the requested project as @project" do
      project = Project.create! valid_attributes
      get :edit, {:id => project.to_param}, valid_session
      expect(assigns(:project)).to eq(project)
    end
  end

  describe "GET solutions.json" do
    it "return a json of solutions" do
      project_one = Project.new title: "a project #1"
      project_one.save
      project_two = Project.new title: "a project #2"
      project_two.save

      real_problem_one = RealProblem.new title: "a real problem"
      real_problem_one.project_id = project_one.id
      real_problem_one.save

      real_problem_two = RealProblem.new title: "a real problem"
      real_problem_two.project_id = project_two.id
      real_problem_two.save

      policy_problem_one = PolicyProblem.new title: "a policy problem"
      policy_problem_one.real_problem_id = real_problem_one.id
      policy_problem_one.save

      policy_problem_two = PolicyProblem.new title: "a policy problem"
      policy_problem_two.real_problem_id = real_problem_two.id
      policy_problem_two.save

      solution_one = Solution.new title: "a solution #1"
      solution_two = Solution.new title: "a solution #2"
      solution_one.policy_problem_id = policy_problem_one.id
      solution_two.policy_problem_id = policy_problem_two.id
      solution_one.save
      solution_two.save

      objective_one = Objective.new title: "a objective #1"
      objective_two = Objective.new title: "a objective #2"
      objective_three = Objective.new title: "a objective #3"
      objective_one.solutions << solution_one
      objective_one.save
      objective_three.solutions << solution_one
      objective_three.save
      objective_two.solutions << solution_two
      objective_two.save

      get :solutions, {:id => project_one.to_param, :format => 'json'}, valid_session

      expect(assigns(:solutions)).to include(solution_one)
      expect(assigns(:solutions)).to_not include(solution_two)
      expect(assigns(:solutions).first.objective_ids.count).to eq(2)
    end
  end

  context "stages" do
    describe "GET stage1" do
      # it "creates a new real_problem as @real_problem" do
      #   get :stage1, {}
      #   expect(assigns(:real_problem)).to be_a_new RealProblem
      # end
      it "renders the stage1 template" do
        get :stage1, {id: @project}
        expect(response).to render_template :stage1
      end
    end

    describe "GET stage2" do
    #   it "creates a new objetive as @objective" do
    #     get :stage2, {}
    #     expect(assigns(:objective)).to be_a_new(Objective)
    #   end
    #   it "assigns an alrealdy created objective as @objective" do
    #     objective = create(:objective)
    #     get :stage2, {objective_id: objective}
    #     expect(assigns(:objective)).to eq(objective)
    #   end
    #   it "lists all created objectives as @objectives" do
    #     objective = create(:objective)
    #     get :stage2, {}
    #     expect(assigns(:objectives)).to include(objective)
    #   end
      it "renders the stage2 template" do
        get :stage2, {id: @project}
        expect(response).to render_template :stage2
      end
    end
  end

  describe "POST create" do
    describe "with valid params" do
      it "creates a new Project" do
        expect {
          post :create, {:project => valid_attributes}, valid_session
        }.to change(Project, :count).by(1)
      end

      it "assigns a newly created project as @project" do
        post :create, {:project => valid_attributes}, valid_session
        expect(assigns(:project)).to be_a(Project)
        expect(assigns(:project)).to be_persisted
      end

      it "redirects to the created project" do
        post :create, {:project => valid_attributes}, valid_session
        expect(response).to redirect_to(Project.last)
      end

      it "assigns a project owner" do
        post :create, {:project => valid_attributes}, valid_session
        owner = User.find(valid_session["warden.user.user.key"][0][0])
        expect(assigns(:project).users.to_a).to include(owner)
        permission = Permission.where(project_id: assigns(:project).id ).where( user_id: owner.id)
        expect(permission.first.role).to eq("owner")
      end
    end

    describe "with invalid params" do
      it "assigns a newly created but unsaved project as @project" do
        post :create, {:project => invalid_attributes}, valid_session
        expect(assigns(:project)).to be_a_new(Project)
      end

      it "re-renders the 'new' template" do
        post :create, {:project => invalid_attributes}, valid_session
        expect(response).to render_template("new")
      end
    end
  end

  describe "POST share" do
    it "adds shared users" do
      project = FactoryGirl.create(:project)
      share_users = "guest_01@ciudadanoi.org, guest_02@ciudadanoi.org"
      post :share, {:id => project.to_param, :share_users => share_users, :message => 'simple message' }, valid_session

      current_u = User.find_by_email(share_users.split(",")[0])

      expect(assigns(:project).users).to include current_u
      # expect(share_users).to include assigns(:project).users.first.email
    end

    it "adds shared users as collaborator" do
      project = FactoryGirl.create(:project)
      share_users = "guest_01@ciudadanoi.org, guest_02@ciudadanoi.org"
      post :share, {:id => project.to_param, :share_users => share_users, :message => 'simple message' }, valid_session

      expect(assigns(:project).users[1].permissions[0].role).to eq "collaborator"
    end

    it "add an existence user on the project and a guest" do
      existence_user = create(:user)
      existence_user_2 = create(:user)

      project = FactoryGirl.create(:project)
      project.users << existence_user
      project.save

      share_users = existence_user_2.email+", guest_03@ciudadanoi.org"
      post :share, {:id => project.to_param, :share_users => share_users, :message => 'simple message' }, valid_session

      expect(assigns(:project).users.find_by_email(existence_user_2.email).permissions.find_by_project_id(assigns(:project).id).role).to eq 'collaborator'
      expect(assigns(:project).users.find_by_email('guest_03@ciudadanoi.org').permissions.find_by_project_id(assigns(:project).id).role).to eq 'collaborator'
    end

    it "share with itself" do
      owner = create(:user)
      the_project = create(:project)
      older_project = create(:project)
      the_project.users << owner
      older_project.users << owner
      permission = Permission.find_by_project_id_and_user_id(the_project.id,owner.id)
      permission.role = :owner
      permission.save

      share_users = owner.email
      post :share, {:id => the_project.to_param, :share_users => share_users, :message => 'simple message' }, valid_session

      expect(assigns(:project).users.find_by_email(owner.email).permissions.find_by_project_id(assigns(:project)).role).to eq 'owner'
    end
  end

  describe "PUT update" do
    describe "with valid params" do
      let(:new_attributes) {
        skip("Add a hash of attributes valid for your model")
      }

      it "updates the requested project" do
        project = Project.create! valid_attributes
        put :update, {:id => project.to_param, :project => new_attributes}, valid_session
        project.reload
        skip("Add assertions for updated state")
      end

      it "assigns the requested project as @project" do
        project = Project.create! valid_attributes
        put :update, {:id => project.to_param, :project => valid_attributes}, valid_session
        expect(assigns(:project)).to eq(project)
      end

      it "redirects to the project" do
        project = Project.create! valid_attributes
        put :update, {:id => project.to_param, :project => valid_attributes}, valid_session
        expect(response).to redirect_to(project)
      end
    end

    describe "with invalid params" do
      it "assigns the project as @project" do
        project = Project.create! valid_attributes
        put :update, {:id => project.to_param, :project => invalid_attributes}, valid_session
        expect(assigns(:project)).to eq(project)
      end

      it "re-renders the 'edit' template" do
        project = Project.create! valid_attributes
        put :update, {:id => project.to_param, :project => invalid_attributes}, valid_session
        expect(response).to render_template("edit")
      end
    end
  end

  describe "DELETE destroy" do
    it "destroys the requested project" do
      project = Project.create! valid_attributes
      expect {
        delete :destroy, {:id => project.to_param}, valid_session
      }.to change(Project, :count).by(-1)
    end

    it "redirects to the projects list" do
      project = Project.create! valid_attributes
      delete :destroy, {:id => project.to_param}, valid_session
      expect(response).to redirect_to(projects_url)
    end
  end

  describe "DELETE unshare" do
    it "remove a user from a project" do
      project = Project.create! valid_attributes
      user_01 = create(:user)
      user_02 = create(:user)
      project.users << user_01
      project.users << user_02

      delete :unshare, {:id => project.to_param, user_id: user_02}

      expect(assigns(:project).users).to include(user_01)
      expect(assigns(:project).users).to_not include(user_02)
    end
  end

end
